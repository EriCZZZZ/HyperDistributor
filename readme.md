# HyperDistributor

a Hyper Distributor for gp

## features

- lock free on modify task
- no task loss

## description

先构建一个工作场景：一个worker线程池，一个任务分发器，一个任务队列。任务分发器将任务推入队列，worker线程从队列中取任务处理。这个场景有一个约束条件：每个任务只能由一个线程处理。

在这个场景中，需要解决的问题是：任务在线程处理的过程中会发生变化，可能有新事件到达，如何高效地实现任务的分发与调度？

以无锁的方式实现事件传递，同时不允许有任务和事件丢失的情况发生。

## requirement analysis

### 概念

#### Distributor

对任务分发器与任务队列的封装，提供接口与约定实现生产者消费者模式。

#### 任务

- 每个任务只能由一个消费者处理。
- 任务被处理的过程中可能被修改。
- 如果一个任务正在被一个消费者处理时发生了后续的变化，后续的变化也只能由该消费者进行处理。

#### 事件

- 具体的，指IO操作就绪；抽象的，其他进程对任务有修改要求

#### 事件的传递

事件发生后，对任务的修改以便通知进程或线程

### 主流程

1. 生产者产生一个任务，通过任务分发器完成生产。
2. 消费者通过向 `Distributor` 接口请求，获得任务并进行处理。 _此处可以加锁_

### 任务修改流程 _Lock free_

1. 生产者或其他能够获得任务指针的角色，通过 `Distributor` 提供的接口进行修改。
2. `Distributor` 通过一系列处理，保证任务能够被完成而不会被丢失。

## design

### 系统划分 

- Distributor
    - 任务队列
        - 就绪队列
        - 阻塞队列
    - 控制器 _向外提供接口_
        - 获取任务
        - 返还任务结果
    
### 有锁实现

针对事件传递的过程进行加锁

事件产生 - 加锁 - 确认状态 - 修改状态与进行相关操作 - 解锁

1. 在阻塞队列时，修改状态，移入就绪队列
1. 在就绪队列时，针对任务分发加锁，修改状态，释放锁
1. task在被处理时，修改状态
1. Distributor在分发和接受任务结果时，检查task的锁

### 无锁实现

#### 时序

## 缩略词对照表

1. SAE: status and events (bits)
